[org 0x7C00]
[bits 16]

global _start

; Jump across the BPB
jmp short _start
nop

; The BIOS parameter block
FAT32_OSName				db		"Hack  OS"
FAT32_BytesPerSector		dw		0
FAT32_SectorsPerCluster		db		0
FAT32_ReservedSectors		dw		0
FAT32_NumFATs				db		0
FAT32_RootEntries			dw		0
FAT32_TotalSectors			dw		0
FAT32_MediaType				db		0
FAT32_SectorsPerFat			dw		0
FAT32_SectorsPerTrack		dw		0
FAT32_HeadsPerCylinder		dw		0
FAT32_HiddenSectors			dd 		0
FAT32_LargeTotalSectors		dd 		0

; The extension block
FAT32_SectorsPerFAT32		dd 		0
FAT32_Flags					dw		0
FAT32_Version				dw		0
FAT32_RootDirStart			dd 		0
FAT32_FSInfoSector			dw		0
FAT32_BackupBootSector		dw		0

; Reserved 
FAT32_Reserved0				dd		0 	;FirstDataSector, there is a sector after the bootloader
FAT32_Reserved1				dd		0 	;ReadCluster
FAT32_Reserved2				dd 		0 	;ReadCluster

FAT32_PhysicalDriveNum		db		0
FAT32_Reserved3				db		0
FAT32_BootSignature			db		0
FAT32_VolumeSerial			dd 		0
FAT32_VolumeLabel			db		"HACKOS PART" ; 11 bytes
FAT32_FSName				db		"FAT32   " ; 8 bytes

_start:
    cli

    xor     ax, ax
    mov     ss, ax
    mov     sp, ax
    mov     ds, ax
    mov     es, ax

    jmp     0x0:safe_start

safe_start:
	mov     [BootDrive], dl ; Remember that the BIOS sets us the boot drive in 'dl' on boot
	mov     sp, 0x7C00 ; set the stack
    mov     bp, sp
    
    sti

	; Enable the A20 line
    call    EnableA20

	; Load the rest of the bootloader, stored right after this sector
	mov 	cx, 1
	mov 	eax, 2
	mov 	bx, 0x7E00
	call 	ReadDisk

	; We are now running
	mov 	bx, BootLoaderString
	call 	Print
	call 	PrintHex

    ; Step 1. Calculate FAT32 Data Sector
	xor		eax, eax
	mov 	al, byte [FAT32_NumFATs]
	mov 	ebx, dword [FAT32_SectorsPerFAT32]
	mul 	ebx
	xor 	ebx, ebx
	mov 	bx, word [FAT32_ReservedSectors]
	add 	eax, ebx
	mov 	dword [FAT32_Reserved0], eax

	; Step 2. Read FAT Table
	mov 	esi, dword [FAT32_RootDirStart]

	; Read Loop
    load_loop:
		mov 	bx, 0x0000
		mov 	es, bx
		mov 	bx, 0x8000
		
		; ReadCluster returns next cluster in chain
		call 	ReadCluster
		push 	esi

		; Step 3. Parse entries and look for szStage2
		mov 	di, 0x8000
		mov 	si, SecondStageNameString
		mov 	cx, 0x000B
		mov 	dx, 0x0020
		;mul by bSectorsPerCluster

		; End of root?
		entry_loop:
			cmp 	[es:di], ch
			je 		_end

			; No, phew, lets check if filename matches
			cld
			pusha
        	repe    cmpsb
        	popa
        	jne 	next

        	; YAY WE FOUND IT!
        	; Get clusterLo & clusterHi
        	push    word [es:di + 14h]
        	push    word [es:di + 1Ah]
        	pop     esi
        	pop 	eax ; fix stack
        	jmp 	LoadFile

        	; Next entry
        	next:
        		add     di, 0x20
        		dec 	dx
        		jnz 	entry_loop

		; Dont loop if esi is above 0x0FFFFFFF5
		pop 	esi
		cmp 	esi, 0x0FFFFFF8
		jb 		load_loop

_end:
	cli
	hlt

%include "print.asm"
%include "disk_reader.asm"
%include "a20_gate.asm"

KernelOffset:   equ 0x8000
BootDrive:     db 0

BootLoaderString: db "HackOS bootloader loaded! Disk: ", 0x00
SecondStageNameString: db "STAGE2  SYS"

times 510 - ($ - $$) nop
dw 0xAA55

%include "fat32.asm"